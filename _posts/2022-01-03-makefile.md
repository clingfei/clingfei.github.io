---
  declare: true
  title: Makefile学习
  categories: Makefile
  tag: 
  - Makefile  

---

---

> Learning by Doing.

<!--more-->

## Makefile学习

### Makefile规则

```makefile
tareget ... : prerequisites ...
command
...
...
```

target是目标文件，可以是Object File 也可以是执行文件，还可以是标签（label), prerequisites是生成target需要的文件或目标

command是make需要执行的指令

如果prerequisites中有任何一个文件比target要新，command中的命令就会被执行

### Example

```makefile
edit : main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o	
```

上面的代码中，目标文件中包含了执行文件和中间目标文件（即*.o），依赖文件就是目标文件冒号后面的文件。这样就构成了最终的目标文件与原始代码之间的依赖关系。

在依赖关系后，后续的command定义了如何生成目标文件的命令，以tab开头。

clean是一个动作名字，执行其后的命令可以需要在make后手动添加标签，即 `make clean`，类似地，可以在一个makefile中定义不用的编译或编译无关的命令，如打包/备份等。

### 变量

在makefile中可以使用变量来简化文件的编写。在makefile中变量可以被视为字符串，类似于C中的宏？

例如：

```
object = main.o kbd.o command.o display.o insert.o searach.o files.o utils.o
```

则可以通过$(objects)来使用这个变量。这样，上面的代码就可以化简为：

```makefile
insert.o search.o files.o utils.o
edit : $(objects)
	cc -o edit $(objects)
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(objects)
```

### 自动推导

make看到.o文件，会自动把.c文件作为他的依赖，并且 cc -c xxx.c也会被自动推导出来。则可进一步化简为：

```makefile
objects = main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
edit : $(objects)
	cc -o edit $(objects)
$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
.PHONY : clean
clean :
	rm edit $(objects)
```

.PHONY说明clean是一个伪目标文件。

### 引用其他的Makefile

Makefile中可以使用include关键字将别的Makefile包含进来。include和文件名之间可以用一个或多个空格隔开。

Makefile寻找文件的顺序：

1. 显式指出的文件位置
2. 当前目录
3. 如果make 执行时有-l 或 --include-dir参数，那么make就会在这个参数所指定的目录下去寻找。
4. 如果\<prefix\>/include (e.g. /usr/local/bin或/usr/include)存在,make会到该目录下去寻找.

如果有文件没有找到，make会生成警告，但不会立刻退出，而是继续载入其他文件，在完成整个makefile的读取后，make再重试这些没有找到或无法读取的文件。若需要make跳过无法读取的文件，则需要在include前加一个'-'.

### 书写规则

规则包含两个部分，一个是依赖关系，另一个是生成目标的方法。

```makefile
tareget ... : prerequisites ...
command
...
...
```

Makefile中存在特殊变量VPATH，如果没有指明这个变量，make会在当前的目录中寻找文件的依赖关系。如果在当前目录中没有找到，会到VPATH所指明的目录中寻找。

```
VPATH = src:../headers
```

如上，makefile将会按照src, ../headers这样的顺序寻找，不同的目录之间用':'分割。

另一个设置文件搜索路径的方法：使用make的vpath关键字

1. vpath \<pattern\> \<directories\> : 为符合模式pattern的文件指定搜索目录
2. vpath \<pattern\> ： 清除符合模式pattern的文件的搜索目录
3. vpath：清除所有被设置好的文件搜索目录

pattern中需要包含%，匹配零或若干字符。例如:

```makefile
vpath %.h ../headers
```

表示在../headers目录下搜索所有以.h结尾的文件

### 伪目标

如果需要一次性生成多个可执行文件，但只要输入一个make，并且所有的目标文件都写在一个makefile中，可以通过伪目标来实现：

```makefile
all : prog1 prog2 prog3
.PHONY : all
prog1 : prog1.o utils.o
	cc -o prog1 prog1.o utils.o
prog2 : prog2.o
	cc -o prog2 prog2.o
prog3 : prog3.o sort.o utils.o
	cc -o prog3 prog3.o sort.o utils.o
```

如上，声明了一个all伪目标，其依赖于其他三个目标。由于伪目标总是被执行，所以其依赖的三个目标总是不如all新，因此另外三条规则总是会被执行，于是就达到了一口气生成多个目标的目的。

### 书写命令

#### 一、 显示命令

make默认将执行的命令行在命令执行前输出到屏幕，若使用@在命令行前，则这个命令将不被显示。

若在make执行时带入参数-n 或 --just-print，则只是显示命令而不执行，可用于调试makefile，查看命令的执行顺序。

make -s 或 --slient可以全面禁止命令的显示

#### 二、命令执行

如果让下一条命令在上一条命令执行的基础上进行，则应该使用';'分隔这两条命令，而不是换行。例如：

```makefile
exec:
	cd /home/hchen; pwd
```

#### 三、命令出错

忽视命令出错，即无论正确不正确都认为是正确的，则在命令前加’-‘。例如：

```makefile
clean:
	-rm -f *.o
```

或给Make添加 -i或 --ignore-errors，忽略所有命令的报错

make -k 或 --keep-going，表示如果某条规则的命令出错了，那么终结该命令的执行，但继续执行其他规则

#### 四、嵌套执行make

把不同模块或不同功能的源文件放在不同的目录中，可以在每个目录中都书写一个该目录的Makefile。例如，有一个子目录subdir,这个目录下有Makefile指明了这个目录下文件的编译规则，则父目录的Makefile可以这样：

```makefile
subsystem:
	cd subdir && $(MAKE)
```

意思是打开subdir目录并make，等价于

```makefile
subsystem:
	$(MAKE) -C subdir
```

总控makefile中定义的变量可以通过export传递到下一级的makefile中，但除非指定-e参数，否则不会覆盖下层的参数。例如：

```
export <variable...>
```

等价于

```makefile
variable = value
export value
```

等价于 

```makefile
export variable := value
```

#### 五、自定义命令包

可以将相同的一组命令序列打包为一个特定的命令。

```makefile
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
```

之后可以通过

```makefile
foo.c:foo.y
	$(run-yacc)
```

执行定义的命令

### 使用变量

变量在声明时需要指定初值，使用时需要加上$，例如：

```makefile
objects = program.o foo.o utils.o
program : $(objects)
	cc -o program $(objects)
$(objects) : defs.h
```

**变量嵌套：**可以把变量的真实值放到后面定义。例如：

```makefile
include_dirs := -Ifoo -Ibar
CFLAGS := $(include_dirs) -O
```

这样前面的变量不能使用后面的变量，而只能使用他前面定义好了的变量

**变量替换：**可以替换变量中共有的部分，例如

```makefile
foo := a.o b.o c.o
bar := $(foo:.o=.c)
```

将foo中的.o全部替换为.c

静态模式替换:依赖于被替换字符串中有相同的模式，模式中必须包含一个%字符。例如：

```makefile
foo := a.o b.o c.o
bar := $(foo:%.o=%.c)
```

**追加变量值：**使用+=，例如：

```makefile
objects = main.o foo.o bar.o utils.o
objects += another.o
```

别的感觉现在用不到，以后再看。

## REFERENCE

[1][全网最牛Linux内核Makefile系统文件详解(纯文字代码) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/437667448?utm_source=wechat_session&utm_medium=social&utm_oi=1236950882178322432&utm_campaign=shareopn)