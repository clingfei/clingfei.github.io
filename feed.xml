<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://clingfei.github.io/</id><title>clingfei</title><subtitle>clingfei's blog</subtitle> <updated>2024-03-31T12:54:00+00:00</updated> <author> <name>clingfei</name> <uri>https://clingfei.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://clingfei.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://clingfei.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 clingfei </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>使用串口调试Linux内核</title><link href="https://clingfei.github.io/_posts/%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/" rel="alternate" type="text/html" title="使用串口调试Linux内核" /><published>2024-03-31T00:00:00+00:00</published> <updated>2024-03-31T00:00:00+00:00</updated> <id>https://clingfei.github.io/_posts/%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/</id> <content src="https://clingfei.github.io/_posts/%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/" /> <author> <name>clingfei</name> </author> <category term="Linux" /> <category term="debug" /> <category term="gdb" /> <summary> 前置要求及环境配置 被调试的主机安装待调试内核，称为target，另一台装有稳定的Linux内核，称为host。 target主板上带有原生com口，不能使用USB转接；需要一台USB转串口母线，连接target串口和host 本文使用的target架构为aarch64, 系统为openeuler，内核为Linux-5.10, host架构为x86-64, 系统为ubuntu 20.04，内核为Linux-5.4。但理论上本文所述的方法在Linux 5.x的发行版上是通用的。 确定串口是否可用 在target上安装minicom： sudo yum install minicom -y 在target上，通过sudo minicom -D /dev/ttyAMA0启动，在host上监听/dev/ttyUSB0，可以接收到来自target minicom的输入，同理，在tar... </summary> </entry> <entry><title>使用qemu进行Linux内核调试</title><link href="https://clingfei.github.io/_posts/%E4%BD%BF%E7%94%A8qemu%E8%BF%9B%E8%A1%8CLinux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/" rel="alternate" type="text/html" title="使用qemu进行Linux内核调试" /><published>2023-09-11T00:00:00+00:00</published> <updated>2023-09-11T00:00:00+00:00</updated> <id>https://clingfei.github.io/_posts/%E4%BD%BF%E7%94%A8qemu%E8%BF%9B%E8%A1%8CLinux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/</id> <content src="https://clingfei.github.io/_posts/%E4%BD%BF%E7%94%A8qemu%E8%BF%9B%E8%A1%8CLinux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/" /> <author> <name>clingfei</name> </author> <category term="Linux" /> <category term="debug" /> <category term="gdb" /> <summary> 一篇创建于2023.9.11，完成于2024.3.31，拖了大半年的文章 调试前的准备 编译qemu 在ubuntu中可以通过apt安装qemu-system，也可以从源码自行编译。在编译qemu-8.0时，可能遇到kvm Parameter 'type' expects a netdev backend type，原因是因为在编译时没有enable-slirp，而enable_slirp需要安装相应的依赖，完整的命令如下： sudo apt-get install libslirp sudo apt-get install libglib2.0-dev cd qemu-8.0 ./configure -enable-slirp make 编译内核 想必大家都会，略过不提 编译磁盘镜像 qemu可以使用多种格式的磁盘镜像，在qemu的文档中给出了一些创建... </summary> </entry> <entry><title>Linux下的TTBR1_EL1寄存器使用探究</title><link href="https://clingfei.github.io/_posts/Linux-TTBR1/" rel="alternate" type="text/html" title="Linux下的TTBR1_EL1寄存器使用探究" /><published>2023-08-14T00:00:00+00:00</published> <updated>2023-08-14T00:00:00+00:00</updated> <id>https://clingfei.github.io/_posts/Linux-TTBR1/</id> <content src="https://clingfei.github.io/_posts/Linux-TTBR1/" /> <author> <name>clingfei</name> </author> <category term="operating system" /> <category term="Linux" /> <summary> 本文分析基于Linux-5.10.100，架构基于ARM64 V8.3，假设页表映射层级为4，即CONFIG_ARM64_PGTABLE_LEVELS=4，地址宽度为48，即CONFIG_ARM64_VA_BITS=48。 在Linux系统中，通过MMU进行虚实地址转换时，会依赖于TTBR1_EL1和TTBR0_EL0两个寄存器。其中TTBR1_EL1指向内核地址空间的页表基地址，TTBR0_EL0指向用户地址空间的页表基地址。 Linux中所有内核线程共享内核地址空间，因此TTBR1_EL1中的值为swapper_pg_dir, swapper_pg_dir在arm64/include/asm/pgtable.h中的定义为： extern pgd_t swapper_pg_dir[PTRS_PER_PGD]; 在使用有效虚拟地址长度为48位，四级页表映射（... </summary> </entry> <entry><title>如何基于LLVM IR分析全局函数指针的使用情况</title><link href="https://clingfei.github.io/_posts/%E5%9F%BA%E4%BA%8ELLVM-IR%E5%88%86%E6%9E%90%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/" rel="alternate" type="text/html" title="如何基于LLVM IR分析全局函数指针的使用情况" /><published>2023-06-23T00:00:00+00:00</published> <updated>2023-06-23T00:00:00+00:00</updated> <id>https://clingfei.github.io/_posts/%E5%9F%BA%E4%BA%8ELLVM-IR%E5%88%86%E6%9E%90%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/</id> <content src="https://clingfei.github.io/_posts/%E5%9F%BA%E4%BA%8ELLVM-IR%E5%88%86%E6%9E%90%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5/" /> <author> <name>clingfei</name> </author> <category term="程序分析" /> <category term="LLVM" /> <summary> 内核中的全局函数指针大致可以分为两种：一种是全局变量本身是一个函数指针，另一种是全局结构体的某个子域是函数指针，例如： struct funcptr { void (*foo)(); }s; void (*fp)(void); 而对这些函数指针的调用，反映到IR上，通常为： fp(): store void ()* @indirect, void ()** @fp, align 8 %8 = load void ()*, void ()** @fp, align 8 call void %8() s.foo(): %9 = load void (...)*, void (...)** getelementptr inbounds (%struct.funcptr, %struct.funcptr* @s, i32 0, i32 0), align 8 ... </summary> </entry> <entry><title>LeetCode 11. 盛最多水的容器</title><link href="https://clingfei.github.io/_posts/11.-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" rel="alternate" type="text/html" title="LeetCode 11. 盛最多水的容器" /><published>2023-06-04T00:00:00+00:00</published> <updated>2024-03-31T12:53:41+00:00</updated> <id>https://clingfei.github.io/_posts/11.-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</id> <content src="https://clingfei.github.io/_posts/11.-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" /> <author> <name>clingfei</name> </author> <category term="Leetcode" /> <category term="algorithm" /> <summary> 迫于最近比较无聊，重操Leetcode旧业，顺带写一下题解。 题目描述 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例：   输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 解法一 首先最简单的思路是直接暴力枚举，依次取两条线计算其储水量，取其中的最大值作为结果。代码如下： class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp... </summary> </entry> </feed>
